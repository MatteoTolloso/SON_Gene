from builtins import dict, print
import sys
import re
import networkx as nx
from itertools import combinations

"""
Dataset ottenuto dalla query:

(SON[Title/Abstract] AND ("DNA-Binding Proteins"[Mesh] OR "RNA-Binding Proteins"[Mesh]) AND "SON protein, human"[nm]) OR "SON gene"[All Fields] OR "SON protein"[All Fields]\
OR NREBP[Title/Abstract]\
OR ("DBP-5"[Title/Abstract] AND "DNA-Binding Proteins"[MeSH])\
OR "NRE-Binding Protein"[Title/Abstract]\
OR KIAA1019[Title/Abstract]\
OR C21orf50[Title/Abstract]\
OR (SON3[Title/Abstract] AND "DNA-Binding Proteins"[MeSH])\
OR DBP5[Title/Abstract]'
"""


def parse_dataset(datasetPath : str) -> dict:
    
    articlesStr : list[str] = []
    
    with open(sys.argv[1],'r') as file:
        articlesStr = list(map(lambda x: x.replace('\n      ', ' '), file.read().split("\n\n")))

    dict = {}
    for art in articlesStr:

        # PubMed ID
        match = re.search('^PMID- (.*)$', art, re.MULTILINE)
        if match is None:
            continue
        pmid = match.group(1)

        # Title
        match = re.search('^TI  - (.*)$', art, re.MULTILINE)
        if match is None:
            continue
        ti = match.group(1)

        # Abstract
        match = re.search('^AB  - (.*)$', art, re.MULTILINE)
        if match is None:
            continue
        ab = match.group(1)

        # NLM Medical Subject Headings (MeSH) controlled vocabulary
        mh = re.findall('^MH  - (.*)$', art, re.MULTILINE)
        if not mh:
            continue
        
        # Includes chemical, protocol or disease terms. May also a number assigned by the Enzyme Commission or by the Chemical Abstracts Service.
        rn = re.findall('^RN  - (.*)$', art, re.MULTILINE)

        # Non-MeSH subject terms (keywords) either assigned by an organization identified by the Other Term Owner, or generated by the author and submitted by the publisher
        ot = re.findall('^OT  - (.*)$', art, re.MULTILINE)

        dict[pmid] = {'Title' : ti, 'Abstract' : ab, 'MeSH' : mh, 'RNnumber': rn, 'OtherTerm': ot }

    return dict

def extract_mesh(articles : dict) -> set:
    mesh_terms = set()
    for art in articles.values():
        local_mesh = art.get('MeSH')
        if local_mesh is not None:
            mesh_terms.update(local_mesh)
    return mesh_terms


def build_cooccurrences_graph(mesh_terms : set, articles : dict) -> nx.Graph:
    graph = nx.Graph()
    graph.add_nodes_from(mesh_terms)

    for art in articles.values():
        for a, b in list(combinations(art.get('MeSH'), 2)):
            if graph.has_edge(a, b):
                graph[a][b]['weight'] += 1
            else:
                graph.add_edge(a, b, weight=1)
    
    return graph
        

def main():

    if(len(sys.argv) < 2):
        print("Usage: $ python3", sys.argv[0], "<path_dataset_pubmed>")
        return
    path = sys.argv[1]

    articles : dict = parse_dataset(path)
    print('Numero di articoli: ', len(articles.keys()))

    mesh_terms : set = extract_mesh(articles)
    print('Numero di MeSH diversi (nodi): ', len(mesh_terms))

    cooccurrences_graph = build_cooccurrences_graph(mesh_terms, articles)
    print('Grafo delle co-occorrenze:\n\tNodi: ', len(cooccurrences_graph.nodes), '\n\tArchi: ', len(cooccurrences_graph.edges))

    cooccurrences_list = list(cooccurrences_graph.edges.data('weight'))

    cooccurrences_list.sort(key = lambda x:x[2], reverse=True)
    
    with open('cooccurrences.txr', 'w') as file:
        for (u, v, wt) in cooccurrences_list:
            file.write(f"({u}, {v}, {wt})\n")



if __name__ == "__main__":
    main()
    
    
    








